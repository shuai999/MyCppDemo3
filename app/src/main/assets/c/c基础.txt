        1. c基础 - 头文件、main函数、打印输出printf、getchar停止
1. 概述
c基础，新建项目后，然后写一个 Hello World，能输出打印，就说明c开发环境已成功安装，
这里主要记录下头文件、main函数、打印输出print、getChar停止的意义。

2 代码如下
    #include<stdio.h>  // 导入头文件，头文件都是方法的声明。
    void main(){  // 函数主入口

        // c语言中的打印输出语句
        printf("Hello World");
        getchar(); // 停止
    }

说明如下：

1： #include<stdio.h>：表示导入头文件，头文件都是方法的声明；
常用的后缀：
     1>：以.h、.hpp结尾的，都是方法的声明；
     2>：以.c（c语言）、.cpp（c++）结尾的，都是方法的实现；
     3>：printf()、getchar()都是c语言的，但是都可以在 cpp 中写，说明 在cpp 中是可以写c语言代码的；
2： main()函数：是函数的主入口；
3： printf(“Hello World”)：是c语言中的打印输出语句；
4： getchar()：表示停止

        2.  c基础 - 占位符使用场景
1. 变量：就是给内存地址取一个别名；
2. 占位符使用场景
    1>：如果只是单纯的打印输出 基本数据类型对应的值，就用每个类型对应的占位符，代码如下：
    #include<stdio.h>  // 导入头文件，头文件都是方法的声明。
    // 基本数据类型
    void main(){

        short s = 100;
        int i = 100;
        long l = 100;

        float f = 200;
        double d = 200;

        char c = 'N';


        // 输出打印，需要用占位符打印

        // short: %d
        // int: %d
        // long：%ld，l是 long，长整型的int

        // float：%f
        // double：%lf，l是 long

        // char字符：%c
        // 字符串：需要用 char*表示

        printf("s的值为：%d\n", s);  // 100
        printf("i的值为：%d\n" , i); // 100
        printf("l的值为：%ld\n", l); // 100
        printf("f的值为：%f\n", f);  // 200.000000
        printf("d的值为：%lf\n", d); // 200.000000
        printf("c的值为：%c\n", c);  // N
        getchar();
    }

    2>：如果是想打印 某个 数据类型的字节数，就直接用 %d就可以，因为字节数就是个数，个数就是int类型，所以直接用 %d就可以：
    #include<stdio.h>  // 导入头文件，头文件都是方法的声明。

    void main(){

        printf("char 数据类型所占字节数：%d\n", sizeof(char)); // 1
        printf("short 数据类型所占字节数：%d\n", sizeof(short));// 2
        printf("int 数据类型所占字节数：%d\n" , sizeof(int));  // 4
        printf("long 数据类型所占字节数：%d\n", sizeof(long));// 4
        printf("float 数据类型所占字节数：%d\n", sizeof(float));// 4
        printf("double 数据类型所占字节数：%d\n", sizeof(double));// 8

        getchar();
    }

3>：如果是想打印地址，需要使用 %p
    printf("a,b的地址分别是：%p,%p\n" , &a , &b);  // a,b的地址分别是：0043F9C8,0043F9BC
    printf("a,b的地址分别是：%p,%p\n", &a, &b);   // a,b的地址分别是：0043F9C8,0043F9BC

        3.  c基础 - 基本数据类型
1. 变量：就是给内存地址取一个别名；
在c语言中的基本数据类型有：short、int、long、float、double、char（字符）、char*（字符串），下边通过代码打印出这几个类型的值。

2. 代码如下
    #include<stdio.h>  // 导入头文件，头文件都是方法的声明。
    // 基本数据类型
    void main(){

        short s = 100;
        int i = 100;
        long l = 100;

        float f = 200;
        double d = 200;

        char c = 'N';


        // 输出打印，需要用占位符打印

        // short: %d
        // int: %d
        // long：%ld，l是 long，长整型的int

        // float：%f
        // double：%lf，l是 long

        // char字符：%c
        // 字符串：需要用 char*表示

        printf("s的值为：%d\n", s);  // 100
        printf("i的值为：%d\n" , i); // 100
        printf("l的值为：%ld\n", l); // 100
        printf("f的值为：%f\n", f);  // 200.000000
        printf("d的值为：%lf\n", d); // 200.000000
        printf("c的值为：%c\n", c);  // N

        getchar();

    }
说明如下：
    1.  输出打印语句，需要使用占位符打印，不能像 java中那样，使用加号：
            print("i的值为："+i)；
            不能像上边这样去写；
    2.  对应占位符如下：
            short：%d；
            int：%d；
            long：%ld，l是 long，是长整型的int；
            float：%f；
            double：%lf，l是 long；
            char字符：%c；
            字符串：需要用 char*表示；

        4.  c基础 - 获取数据类型所占字节数
1. 变量：就是给内存地址取一个别名；
2. 用 sizeof(int) 可以获取对应类型所占字节数；
3. 代码如下
    #include<stdio.h>  // 导入头文件，头文件都是方法的声明。

    void main(){

        printf("char 数据类型所占字节数：%d\n", sizeof(char)); // 1
        printf("short 数据类型所占字节数：%d\n", sizeof(short));// 2
        printf("int 数据类型所占字节数：%d\n" , sizeof(int));  // 4
        printf("long 数据类型所占字节数：%d\n", sizeof(long));// 4
        printf("float 数据类型所占字节数：%d\n", sizeof(float));// 4
        printf("double 数据类型所占字节数：%d\n", sizeof(double));// 8

        getchar();
    }

由于上边打印的全部是所占字节数，是个数，个数是int类型，所以占位符全部用的是 %d，
而不是之前打印基本数据类型的对应的占位符，由代码可知：
char：所占字节数为 1；
short：所占字节数为2；
int：所占字节数为4；
long：所占字节数为4；
float：所占字节数为 4；
double：所占字节数为 8；

        5.  c基础 - 指针变量 和 获取地址的值
1. 变量：就是给内存地址取一个别名；
2. 比如：
   在 java 中定义：int i = 100；用变量 i 接收 100这个数据；
   在 c 中定义：int i = 100 ； int* p = &i；
   在 c 语言中：

   指针变量：
       上边的 p 就是指针变量；
       相当于地址变量。 指针指向的就是变量的地址 或者 指针存放的就是变量的地址，
       也就是说 p 指向的就是 i的地址 或者 p存放的就是 i的地址；

   1.  用 &i 来获取 变量 i 的地址；
   2.  用 指针变量 int* p 来接收 &i 的返回值， 如 int* p = &i；
   3.  int*：表示int类型的指针，或者int 类型的地址，是用于接收int类型的指针；

   获取地址的值：
       用 * 来获取地址的值 ；
   1.  *(&i) 就是用来获取 i的地址的 值；
   2.  int* p = &i中：int*表示int类型的指针 或者 int类型的地址，用于接收int类型的指针；
   3.  p：这里的p已经是地址了，是指针的变量，可以直接通过 *p获取值；
   4.  *p：表示获取 地址 &i 的值；

   下边两句输出语句是一样的：
   printf("i的值为：%d\n" , *(&i));
   printf("i的值为：%d\n", *p);
   也就是说：根据int* p = &i可知：指针变量p就是 指向&i的地址 或者说 指针变量p存放的就是 &i的地址

3. 代码如下：
#include<stdio.h>  // 导入头文件，头文件都是方法的声明。
void main(){
    int i = 100;
    double d = 200;

    printf("i的值为：%d\n" , i); // 100

    // 通过 *获取地址的值
    printf("i的值为：%d\n" , *(&i)); // 100, 首先获取i的地址&i，然后获取该地址对应的值 *(&i)

    // 指针变量，相当于地址变量：指针指向的就是变量地址 或者 存放的就是变量的地址

    // int* ：表示int类型的指针，或者int类型的地址，用于接收int类型的指针
    // p：是指针的变量
    int* p = &i;
    // 获取到i的地址后，再打印i的值：
    printf("i的值为：%d\n", *p); // 100， *p：表示对地址i去取值

    // double*：表示double类型的指针，或者double类型的地址，用于接收 double 类型的指针
    // double* pl = &d;
    getchar();
}


        6.  c基础 - debug调试 根据地址查询该地址对应数据值
1.  下边通过代码演示： 通过打印 i 的地址，然后用 debug的方式调试，用于验证 根据 变量i的地址可以查询出这个地址对应的数据。
    下边先说下 c语言中的 变量的地址。

2. 变量的地址
    定义：任何的数据 或者 任何的变量都会有地址，这个地址就相当于我们生活中的住址和门牌号，
    因为在 c和c++中的所有操作基本都是去操作指针。

3.  代码如下
下边代码意思是：
1>：定义变量 i = 100，用占位符 %p，用于打印输出 i的地址，打印结果为：0034FDC0；
2>：然后采用debug方式调试，把这个地址0034FDC0粘贴到输入框中，用于查询这个地址对应的值，看是否是100，如果这个值是100，
    就验证了 可以根据地址查询该地址对应的数据，具体debug流程，看下边第4的断点调试

    #include<stdio.h>  // 导入头文件，头文件都是方法的声明。
    void main(){

        int i = 100;
        // &: 表示取变量的地址
        // 通过 debug的调试：我们可以根据地址去查询 该地址对应的数据。
        // int类型是4字节，sizeof()：获取数据类型所占字节数
        printf("i的地址是：%p" , &i);
        getchar();
    }

说明如下：
    1.  &：表示获取变量的地址，&i就是获取 变量i的地址；
    2.  int类型是4 字节，sizeof()方法用于获取数据类型所占字节数
4. 断点调试
    通过 debug 断点调试，可以根据地址去 查询 该地址对应的数据；

    1>：在代码左边单击；
    2>：然后点击调试；
    3>：然后点击 逐语句，这个是下一步的意思；
    4>：这个时候在 doc中，就会打印出i的地址，然后鼠标在doc的上边右键 -> 标记 -> 选中地址 -> 右键 -> 复制，这个时候就会复制这个地址

    5>：然后点击 调试下边步骤：
    点击 调试 - 窗口 - 内存 - 内存1（1）
    6>：然后把上边复制的地址粘贴到这个输入框中，敲回车，会发现地址看不懂，没有关系，这些都是系统的一些地址，
        不需要关心，发现下边数字是64，不对，这里就需要在这些地址框上边 右键 -> 选中4字节整数，因为int是4字节；

        7.  c基础 - 通过指针变量、方法、地址修改值
1. 变量：就是给内存地址取一个别名；
2. 这里记录下：通过指针变量修改值、通过方法修改值、通过地址修改值；
    1.  通过指针变量修改值：有两种方式
            1>：直接给变量重新赋值；
            2>：获取指针变量p的值，间接修改；
    2.  通过方法修改值：
            通过运行代码，发现 修改前的i的值 与 change(int i)方法中的i的地址不是同一个，所以无法修改；
            根据这个可以得出一个结论：在以后见到都是有用的：只要通过方法修改两个变量的值，都是无法修改的，
            因为这两个变量的地址已经变了，所以无法修改；
    3.  通过地址修改值：
            这里就需要把地址给传递进来，用 int* p来接收传递过来的地址，这里的p就已经是地址了，可以直接打印p，
            就表示输出的是 地址；

3. 代码如下
    1>：通过指针变量修改值：一般有两种方式：
    a：直接给变量重新赋值；
    b：获取指针变量p的值，间接修改；

    #include<stdio.h>  // 导入头文件，头文件都是方法的声明。
    // 通过指针修改值
    void main(){

        // 定义变量 i
        int i = 100;
        // 获取 i的地址，用指针变量 int* p来接收
        int* p = &i;

        // 方式 1：直接给 i重新赋值
        i = 200;
        // 方式 2：获取指针变量 p的值，来间接修改
        // *p：表示 获取指针变量 p的值，来修改i的值
        *p = 300;

        printf("i的值为：%d\n", i);  // 300
        getchar();
    }

2>：通过方法修改值：
    通过运行代码，发现 修改前的i的值 与 change(int i)方法中的i的地址不是同一个，所以无法修改；

    #include<stdio.h>  // 导入头文件，头文件都是方法的声明。

    // 在c中，调用顺序是从上往下执行，所以调用方法需要写到上边
    // 通过方法修改值：通过打印可知：i的地址和change中的地址不是同一个，所以无法修改，这里可以通过地址来修改
    void change(int i){
        printf("change中i的地址是：%p\n", &i);   // i的地址是：0019F894
        i = 200;
    }

    void main(){
        int i = 100;
        printf("i的地址是：%p\n", &i);  // i的地址是：0019F968
        printf("i的值为：%d\n" , i);
        // change(i);
        change(&i);
        printf("i修改后的值为：%d\n", i);
        getchar();
    }

3>：通过地址修改值：可以修改成功，i修改后的值 为 200 ；
    #include<stdio.h>  // 导入头文件，头文件都是方法的声明。

    // 通过地址修改值：这里就需要把地址传递进来，用int* p来接收传递过来的地址，因为 这里的 p 就相当于 p = &i，
    // 所以 这里的 p就已经是地址了；
    void change(int* p){
        printf("change中i的地址是：%p\n", p);// 这里的p已经是地址，可以直接打印
        *p = 200; // 通过 *p就可以获取 p地址的值，然后给其赋值为200
    }

    void main(){
        int i = 100;
        printf("i的地址是：%p\n", &i);  // i的地址是：0019F968
        printf("i的值为：%d\n" , i);
        // change(i);
        change(&i);
        printf("i修改后的值为：%d\n", i);  // 200
        getchar();
    }


        8.  c基础 - 题目：用两种方法对两个值进行交换
1. 变量：就是给内存地址取一个别名；
2. 用两种方法对两个值进行交换
    方法一：定义中间变量temp，让两个值进行交换，思路如下：
        1.  在 main() 方法中定义两个int类型的变量：int a = 100 ，int b = 200 ；
        2.  在 main() 方法中的 change(&a，&b) 需要传递 ab的地址；
        3.  在 main() 方法上边写一个 change(int* a，int* b)方法，用于交互ab的值，这里的 a和b已经是地址了，
            相当于 a=&a，b=&b ；
        4.  而 *a = *b：表示：对a的地址取值 = 对b的地址取值；

        这样，就实现了ab两个值的交换：结果为 200  100；

    方法二为面试题
    方法二：不能开辟额外内存，意思就是不能用中间变量，交换两个值，思路如下：
        // 交换
        a = a + b; // a = 100 + 200 = 300
        b = a - b; // b = 300 - 200 = 100
        a = a - b; // a = 300 - 100 = 200

3.  代码如下
    1>：方法一：定义中间变量temp，代码如下：
    #include<stdio.h>  // 导入头文件，头文件都是方法的声明。

    // 这里用 int类型的指针 int* 接收传递过来的两个地址，此时的 a和b已经是两个地址了
    void change(int* a , int* b){
        int temp = *a;
        *a = *b; // 对a的地址取值 = 对b的地址取值
        *b = temp;
    }
    void main(){
        int a = 100;
        int b = 200;

        // 交换：这里直接传递ab的地址
        change(&a , &b);
        printf("交互后ab的值分别是：%d,%d",a,b);  // 200 100

        getchar();
    }

2>：方法二：不能开辟额外内存，意思就是不能用中间变量，代码如下：
    #include<stdio.h>  // 导入头文件，头文件都是方法的声明。

    void main(){
        int a = 100;
        int b = 200;

        // 交换
        a = a + b; // a = 100 + 200 = 300
        b = a - b; // b = 300 - 200 = 100
        a = a - b; // a = 300 - 100 = 200
        printf("交互后ab的值分别是：%d,%d", a, b);  // 200 , 100
        getchar();
    }

4. 注意事项：
    选中方法，右键，转到声明，可以看到该方法的返回值，以及需要传递的参数

        9.  c基础 - 疑难问题
1. 变量：就是给内存地址取一个别名；
2. 定义
   int a = 100 ；
   int b = 100 ; // a = b：表示把 b的值赋值给a；
   printf("a,b的地址分别是：%p,%p\n" , &a , &b); // a,b的地址分别是：0043F9C8,0043F9BC

   int* p1 = &a； // 把 a的地址 赋值给 变量p1
   int* p2 = &b； // 把 b的地址 赋值给 变量p2
   p1 = p2； // p1 = p2有点类似于 a=b，p1和p2只是一个变量而已，这里只是把 p2的值赋值给p1，导致p1变量的值修改了，并没有修改 a的地址
   printf("a,b的地址分别是：%p,%p\n", &a, &b); // a,b的地址分别是：0043F9C8,0043F9BC

3. 代码如下
    #include<stdio.h>  // 导入头文件，头文件都是方法的声明。

    void main(){
        int a = 100;
        int b = 100;

        // a = b: 表示把b的值赋值给a
        printf("a,b的地址分别是：%p,%p\n" , &a , &b);  // a,b的地址分别是：0043F9C8,0043F9BC


        // 把 a的地址赋值给 变量p1，把 b的地址赋值给 变量p2
        int* p1 = &a;
        int* p2 = &b;

        // p1 = p2有点类似于 a=b，p1和p2只是一个变量而已
        // 这里只是把 p2的值赋值给p1，导致 p1变量的值修改了，并没有修改a的地址
        p1 = p2;
        printf("a,b的地址分别是：%p,%p\n", &a, &b);   // a,b的地址分别是：0043F9C8,0043F9BC
        getchar();
    }

可以看到上边两次打印结果：

第一次：a，b的地址分别是：0043F9C8，0043F9BC；
第二次：a，b的地址分别是：0043F9C8，0043F9BC；

a，b的地址都没有发生变化；


        10.  c基础 - 二级指针和多级指针
 1.  二级指针：就是对一级指针再取地址；
 2.   代码如下：
    #include<stdio.h>  // 第一步：导入头文件

    // 程序主入口
    void main(){

        // 二级指针：就是对一级指针取地址

        int num = 12;
        // int*: 是指针，用于接收num地址返回值  &：获取地址
        int* p = &num;

        // int**：表示对p取地址
        int** s_p = &p;
        // 意思就是：s_p存的是p的地址 p存的是num的地址

        // s_p的值是：0x0042FBC4， 上边存储的是p的地址0042fbd0
        // p的地址：刚好就是0042fbd0，p上边存储的值0042fbd0，
        // 0042fbd0就是num的地址，num上边存的值是 +12
        printf("p 的值是：%p , s_p 的值是：%p" , p , s_p);

        // 如果想知道s_p的地址，可以写成下边代码
        // int*** s_s_p = &s_p; 多级指针

        // 通过二级指针怎么获取到最终的值？ s_p (*代表取值)
        printf("获取最终的值是：%d" , **s_p); // 获取最终的值是：12

        // 暂停
        getchar();
    }

3. 分析代码
    1>：下断点到 printf("p 的值是：%p , s_p 的值是：%p" , p , s_p)前边，然后运行代码；
    2>：运行的结果是：p 的值是：0042FBD0 , s_p 的值是：0042FBC4，只看s_p的值，不看p的值；
    3>：点击上边的调试 -> 窗口 -> 内存1，把s_p的值粘贴到里边，然后回车；
    4>：然后在下边区域，右键 -> 点击4字节 -> 十六进制显示，然后回车，可以看到下边绿色框中的值；

4. num、p、s_p三者关系如下：
    分析上边代码：
    1>：我们可以首先打印输出 printf("p 的值是：%p , s_p 的值是：%p" , p , s_p)的值，获取到 s_p的值是 0x0042FBC4；
    2>：然后 把0x0042FBC4值放到上边，回车后，就变成0042fbd0；
    3>：然后 把0042fbd0放到上边，用带符号显示，就变成 +12；

    其实这个意思就是：
    a： 首先获取到s_p的值，然后通过s_p的值获取到p的值，然后通过p的值获取到num的值；
    也就是说 s_p中存储的是p的地址，p中存储的是num的地址

         11.  c基础 - for循环写法
1. 在java中的for循环与c中的for循环写法稍微有点区别，代码如下：
// 数组与数组指针
void main(){

    // 定义一个数组
    int arr[] = {1,2,3,4};

    // 遍历数组，这种写法用到Linux上，可能会有问题
    for (int i = 0; i < 4; i++){
        printf("%d\n" , arr[i]);
    }

    // 第二种：for循环在c与c++中的正确写法，以后在c和c++中写for循环用下边这种方式就可以
    int i = 0;
    for (; i < 4;i++){
        printf("%d\n", arr[i]);
    }

    getchar();
}

从上边代码可以看出：
在c或c++中，如果需要使用for循环的话，直接用第二种，不要使用第一种，
第一种可能会由于编译器或者开发工具或者操作系统等各种原因可能会有问题。

            12.  c基础 - 数组和数组指针
 1. 看一组现象
    // 数组与数组指针
    void main(){

        // 定义一个数组
        int arr[] = {1,2,3,4};

        // 看一种现象： arr的值 = arr取地址的值 = arr[0]的地址的值，arr[0]的值就是首地址
        printf("arr = %p\n" , arr); // 打印数组： arr = 003DFE84
        printf("arr& = %p\n", &arr);// 打印数组地址： arr& = 003DFE84
        printf("arr[0]& = %p\n", &arr[0]); // 打印数组第0个位置的地址： arr[0] & = 003DFE84

        getchar();
    }

从上边代码可以看出：
arr的值 = arr取地址的值 = arr[0]的地址的值，而这个 arr[0]的值就是 首地址，这个首地址很重要。

2. 如何获取数组指针？
    数组指针 指向的就是 数组的首地址，也就是 数组 第一个元素的地址。
    可以根据下边方式获取数组指针：
    // 数组与数组指针
    void main(){

        // 定义一个数组
        int arr[] = {1,2,3,4};

        // 看一种现象： arr的值 = arr取地址的值 = arr[0]的地址的值，arr[0]的值就是首地址
        printf("arr = %p\n" , arr); // 打印数组： arr = 003DFE84
        printf("arr& = %p\n", &arr);// 打印数组地址： arr& = 003DFE84
        printf("arr[0]& = %p\n", &arr[0]); // 打印数组第0个位置的地址： arr[0] & = 003DFE84

        // 如何获取数组的指针
        // int[]* arr_p = &arr; 这种写法不行，因为c中没有这种写法

        // 数组指针一般都是：用int*去接，然后直接等于arr就可以
        int* arr_p = arr ;
        getchar();
    }

所以以后如果要获取数组的指针，可以直接 int* arr_p = arr ;就可以了
3. 挪动数组指针
// 数组与数组指针
void main(){

    // 定义一个数组
    int arr[] = {1,2,3,4};

    // 数组指针一般都是：用int*去接，然后直接等于arr就可以
    // arr可以看做是上边的arr[0]
    // 数组指针指向的是数组的首地址
    int* arr_p = arr;

    // 数组第1位值
    printf("%d\n" , *arr_p); // *arr_p: 就是对arr取值，也就是对 arr[0]取值，也就是1

    // 比如：对指针++

    // 数组指针挪动1位
    arr_p++;                // 对指针++，表示指针从1移动到2的位置，然后再通过 *arr_p对指针取值，就是2
    printf("%d\n", *arr_p);

    // 数组指针从2的位置：再移动2位，就到4的位置了
    arr_p += 2;
    printf("%d\n", *arr_p); // 4

    // 数组指针从4的位置：再移动1位，由于已经超出了自定义 arr的范围，这个时候指针就移动到了系统内存中了，
    // 这个时候打印的值就是系统的内存的值，我们看不懂，但是这里不会角标越界
    arr_p += 1;
    printf("%d", *arr_p);

    // 上边输出语句打印结果如下：
    //  1
    //  2
    //  4
    //  - 858993460  这个是系统内存的值，我们看不懂
    getchar();
}

4. 分析如下
    分析：
    1.  定义int* arr_p = arr之后，就表示指针 arr_p已经在数组第一个位置，也就是 *arr_p，因为 *arr_p = arr[0]
        的值，所以 arr_p的指针指向数组第一个值就是 1，  此时    printf("%d\n" , *arr_p) 的值就是1；
    2.  arr_p++：表示指针向后移动一位，就移动到了 2的位置，此时  printf("%d\n", *arr_p) 的值就是2；
    3.  arr_p += 2：表示指针从 上边2 的位置移动 2位，到4，此时  printf("%d\n", *arr_p) 的值就是4；
    4.  如果把上边的 arr_p += 2换成 arr_p += 3：表示指针从 2的位置移动到 4的后一位，由于已经超出了 定义的arr
        数组范围，所以 这个时候指向的就是 系统的内存，但是角标不会越界；

        13.  c基础 - 采用指针，遍历数组及循环赋值
1. 采用指针 进行 遍历数组：
    // 采用指针遍历数组
    void main(){

        // 定义数组
        int arr[] = {1,2,3,4};
        // 采用指针对数组进行赋值
        int* arr_p = arr;

        // 循环遍历数组
        int i = 0;
        for (; i < 4;i++){
            printf("位置%d的值是：%d\n" , i , *(arr_p+i));
        }

        // 位置0的值是：1
        // 位置1的值是：2
        // 位置2的值是：3
        // 位置3的值是：4

        getchar();

    }

2. 采用指针 进行 循环赋值：
    // 循环赋值
    void main(){

        // 指定数组，并且长度是4
        int arr[4];
        // 采用指针对数组进行赋值
        int* arr_p = arr;

        int i = 0;
        for (; i < 4; i++){
            // 循环赋值
            *(arr_p + i) = i;
        }

        i = 0;
        for (; i < 4;i++){
            printf("位置%d的值是：%d\n", i, arr[i]);
        }

        // 位置0的值是：0
        // 位置1的值是：1
        // 位置2的值是：2
        // 位置3的值是：3
        getchar();

    }

        14.  c基础 - 数组指针常见操作的几种方式
1. 数组指针常见操作方式有3种
    // 第一种：
    // 循环赋值 - 开发中一般不会使用这种方式
    void main(){

        // 指定数组，并且长度是4
        int arr[4];
        // 采用指针对数组进行赋值
        int* arr_p = arr;

        int i = 0;
        for (; i < 4; i++){
            // 循环赋值
            *(arr_p + i) = i;
        }

        i = 0;
        for (; i < 4;i++){
            printf("位置%d的值是：%d\n", i, arr[i]);
        }

        // 位置0的值是：0
        // 位置1的值是：1
        // 位置2的值是：2
        // 位置3的值是：3
        getchar();

    }


    // 数组指针操作的几种方式
    void main(){
        int arr[] = {1,2,3,4};

        int* arr_p = arr;

        int i = 0;
        for (; i < 4;i++){
            // 第二种：
            // printf("位置%d的值是：%d\n" , i , *(arr+i));
            // 由 int* arr_p = arr可知：arr = arr_p，所以直接打印 *(arr+i)表示值

            // 第三种：
            printf("位置%d的值是：%d\n", i, arr_p[i]); // == *(arr+i)
        }
        getchar();
    }

2. 总结
    以后在开发过程中，对于for循环遍历数组指针，最常用的就是：
    void main(){
        int arr[] = {1,2,3,4};

        int* arr_p = arr;

        int i = 0;
        for (; i < 4;i++){
            printf("位置%d的值是：%d\n", i, arr_p[i]); //  arr_p[i] == *(arr+i)

            // 打印结果如下：arr_p[i]的值就是0、1、2、3
            // 位置0的值是：0
            // 位置1的值是：1
            // 位置2的值是：2
            // 位置3的值是：3
        }
        getchar();
    }


        15.  c基础 - 指针为什么要有类型？
1. 指针其实就是一块地址，而且它的值都差不多 都是 类似003DFE84，都是 00+6位数字或字母 这种方式，
        那么为什么指针要有类型呢？原因如下：

取值的时候，我要知道怎么取，比如是按照4字节、8字节、16字节，就是debug方式，调试 - 窗口 - 内存 - 内存1，这样去查看；
指针的偏移：如果用 int* 接收，那么指针移动时按4字节来移动，double*接收，移动时按照8字节来移动；

2. 代码如下
// 指针为什么要有类型？ 指针其实就是一块地址，而且它的值都差不多，
// 原因有2个：
// 1. 取值的时候，我要知道怎么取：4字节、8字节、16字节，就是debug方式，调试 - 窗口 - 内存 - 内存1，这样去查看；
// 2. 指针的偏移：指针移动时，如果是int类型指针，按照4字节移动；如果是double类型指针，按照8字节移动
void main(){
    int num = 12;

    int* num_p = &num;

    // double* num_p_d = num;

    printf("%p" , num_p);
    getchar();
}

        16.  c基础 - 函数指针定义
1. 函数指针
    函数指针用的最多的就是 回调，在 java中一般是通过对象、通过接口来回调，在c和c++中就是通过 函数指针来实现回调

2. 格式
    方法的返回值( * 方法的名称)(方法的参数)
    比如：void(*add_p)(int, int);

3. 示例代码如下
    // 函数指针，相当于 回调

    // 两个数相加
    void add(int num1 , int num2){
        printf("num1 + num2 = %d\n" , (num1+num2));  // num1 + num2 = 3
    }

    // 两个数相减
    void mins(int num1, int num2){
        printf("num1 - num2 = %d", (num1 - num2));  // num1 - num2 = -1
    }

    // 参数1：方法指针（类似于java中的接口），两个数
    void operate(void(method)(int,int) , int num1 , int num2){
        method(num1, num2);
    }


    void main(){

        // 在这个Simple.cpp中可以直接用下边方式调用；
        add(1,2);

        // 但是想要在另一个文件调用add方法，就不能这么调用了，其实另外一个文件也是可以调用这个方法的，需要把 函数指针传给另一个方法就可以

        // 方法指针的定义格式如下：
        // 方法的返回值* (方法的名称)(方法的参数)
        // void* (add_p)(int, int);

        operate(add , 1 , 2);
        operate(mins, 1, 2);

        getchar();
    }

        17.  c基础 - 函数指针的使用场景
1. 函数指针回顾
    函数指针定义格式：
    方法返回值(* 方法名称)(参数1,参数2)
    比如：void(prinf_m)(char)，方法名称随便定义，多个参数用逗号隔开

2. 函数指针使用场景
  1>：监听数据压缩回调 - 打印进度
    // 监听数据压缩回调
    void call_back(int current , int total){
        printf("压缩的进度是：%d/%d" , current , total);  // 12/24
    }


    // 压缩的方法，这个compress就相当于是另一个文件，我们需要在另一个文件中回调
    // 参数1：压缩的文件名；参数2：回调方法，就是上边的call_back
    void compress(char* file_name  ,void(call_back)(int , int)){
        call_back(12 , 24);
    }

    void main(){

        compress("1.png" , call_back);
        getchar();
    }
2>：监听数据压缩回调 - 打印log
        把 函数指针 作为参数传递

        // 方法指针使用场景（视频压缩回调）
        void print(char* message){
            printf("打印内容：%s" , message);

        }

        // 把函数指针作为参数传递
        void method(void(*prinf_m)(char*)){
            prinf_m("指针函数回调");  // 打印内容：指针函数回调
        }

        void main(){

            // print, &print：这两个打印结果一样，打印的都是 print方法的地址，所以下边直接用 print来接收方法指针
            // printf("%p , %p", print, &print);  // 00C411FE , 00C411FE

            // 用一个指针接收 printf方法
            // 下边就是一个方法指针：方法返回值(*方法名称)(参数)：方法名称随便定义，多个参数的话用 , 逗号隔开
            void(*prinf_m)(char*) = print;
            // void(*prinf_m)(char*) = &print;  这样也可以

            // 直接传递print就可以，因为传递的参数就需要指针
            method(print);
            getchar();
        }

这里需要注意：
// 00C411FE , 00C411FE 可知：print和 &print都是 print方法的地址，所以直接可以用 print来接收方法指针
通过 输出语句： printf("%p , %p", print, &print);
void(prinf_m)(char) = print;
void(prinf_m)(char) = &print; 这样也可以

3. 分析上边代码执行流程
代码已上传至github：
https://github.com/shuai999/NDK-day07.git


        18.  c基础 - 如何文档阅读 - 随机数示例及使用场景
1. 如何文档阅读？
    通过举一个示例，生成随机数来看下

2.   随机数代码如下
    #include<stdio.h>
    #include <stdlib.h>
    #include <time.h>   // 这3个都是导包

    // 生成随机数
    void main(){


        // 解决方式：初始化发生器 ，每次发生器都是当前时间
        // time表示每次运行时，发生器都是当前时间
        srand((unsigned)time(NULL));

        // 生成10个 100以内的随机数
        // 可以随机，但是每次运行的随机数都一致
        int i;
        for (i = 0; i < 10;i++){
            printf("%d\n" , rand() % 100);
        }
        getchar();
    }

上边代码分析：
如果直接用下边代码实现，可以生成随机数，但是每次运行结果都一样
        int i;
        for (i = 0; i < 10;i++){
            printf("%d\n" , rand() % 100);
        }

解决方式：初始化发生器，每次发生器都是当前时间，time表示每次运行时，发生器都是当前时间，
给上边代码添加这个方法就可以：
    srand((unsigned)time(NULL));


3. 随机数使用场景
    使用场景：在C层 生成秘钥：
        秘钥其实就是 把 java层代码变成 .so库，这样就看不到 java层的代码了。生成秘钥就需要使用 随机数，
        直接用 rand不行的话，就需要给上边加上srand，用 so生成秘钥之后就更加安全。
